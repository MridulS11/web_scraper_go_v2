Build, deploy, and monitor AI models and apps.
Get consistency across operating environments.
Simplify the way you build, deploy, and manage apps.
Scale automation and unite tech, teams, and environments.
Modernize operations for virtualized and containerized workloads.
Control and protect critical infrastructure. 
Code, build, deploy, and monitor security-focused software.
Deploy workloads closer to the source with edge technology.
Learn how to use our cloud products and solutions at your own pace in the Red Hat® Hybrid Cloud Console. 
Develop and deploy AI solutions across the hybrid cloud.
Support hybrid cloud innovation on a flexible operating system.
Build, modernize, and deploy apps at scale.
Implement enterprise-wide automation.
Discover resources and tools to help you build, deliver, and manage cloud-native applications and services.
Find solutions from our collaborative community of experts and technologies in the Red Hat® Ecosystem Catalog.
We'll recommend resources you may like as you browse. Try these suggestions for now.
A subscription may be required for some services.
 Edit avatar
Login: [[login]]
Account number: [[account_number]]
[[email]]
Share
File permissions are core to the security model used by Linux systems. They determine who can access files and directories on a system and how. This article provides an overview of Linux file permissions, how they work, and how to change them.
The ls command along with its -l (for long listing) option will show you metadata about your Linux files, including the permissions set on the file.
In this example, you see two different listings. The first field of the ls -l output is a group of metadata that includes the permissions on each file. Here are the components of the vimrc listing:
The fields "File type" and "Extended attributes" are outside the scope of this article, but in the featured output above, the vimrc file is a normal file, which is file type - (that is, no special type).
The tuned listing is for a d, or directory, type file. There are other file types as well, but these two are the most common. Available attributes are dependent on the filesystem format that the files are stored on. For Red Hat Enterprise Linux 7, 8, and 9, the default filesystem format is XFS.
This article is about the permission settings on a file. The interesting permissions from the vimrc listing are:
This string is actually an expression of three different sets of permissions:
The first set of permissions applies to the owner of the file. The second set of permissions applies to the user group that owns the file. The third set of permissions is generally referred to as "others." All Linux files belong to an owner and a group.
When permissions and users are represented by letters, that is called symbolic mode. For users, u stands for user owner, g for group owner, and o for others. For permissions, r stands for read, w for write, and x for execute.
[ Learn how to manage your Linux environment for success. ]
When the system is looking at a file's permissions to determine what information to provide you when you interact with a file, it runs through a series of checks:
Permissions go beyond the different types of people that can interact with a file. Each user gets an expression that includes the three basic types of permissions. In the example above, the owner of the file is given the following permissions:
Each character in the expression indicates whether a specific permission is granted or not. In the example above, read (r) permission and write (w) permission have been granted on the file. However, the execute permission (x) is not granted, which is why there's a - sign in the expression. The permission in this field is disabled.
Consider the group owner's permissions in this example:
The read (r) permission is granted to members of the group, but write and execute have both been disabled.
[ Keep your most commonly used commands handy with the Linux commands cheat sheet. ]
When Linux file permissions are represented by numbers, it's called numeric mode. In numeric mode, a three-digit value represents specific file permissions (for example, 744.) These are called octal values. The first digit is for owner permissions, the second digit is for group permissions, and the third is for other users. Each permission has a numeric value assigned to it:
In the permission value 744, the first digit corresponds to the user, the second digit to the group, and the third digit to others. By adding up the value of each user classification, you can find the file permissions.
For example, a file might have read, write, and execute permissions for its owner, and only read permission for all other users. That looks like this:
The results produce the three-digit value 744.
I've talked about how to view file permissions, who they apply to, and how to read what permissions are enabled or disabled. But what do these permissions actually do in practice?
Read permission is used to access the file's contents. You can use a tool like cat or less on the file to display the file contents. You could also use a text editor like Vi or view on the file to display the contents of the file. Read permission is required to make copies of a file, because you need to access the file's contents to make a duplicate of it.
Write permission allows you to modify or change the contents of a file. Write permission also allows you to use the redirect or append operators in the shell (> or >>) to change the contents of a file. Without write permission, changes to the file's contents are not permitted.
Execute permission allows you to execute the contents of a file. Typically, executables would be things like commands or compiled binary applications. However, execute permission also allows someone to run Bash shell scripts, Python programs, and a variety of interpreted languages.
[ Download now: A sysadmin's guide to Bash scripting. ]
There are other ways to execute the contents of a file without execute permission. For example, you could use an interpreter that has execute permission to read a file with instructions for the interpreter to execute. An example would be invoking a Bash shell script:
The executable being run is bash. The script.sh file is read by the Bash interpreter, and its commands are executed. The content in this article is general purpose, but in Linux, there are often additional ways to accomplish tasks.
Directory file types are indicated with d. Conceptually, permissions operate the same way, but directories interpret these operations differently.
Like regular files, this permission allows you to read the contents of the directory. However, that means that you can view the contents (or files) stored within the directory. This permission is required to have things like the ls command work.
As with regular files, this allows someone to modify the contents of the directory. When you are changing the contents of the directory, you are either adding files to the directory or removing files from the directory. As such, you must have write permission on a directory to move (mv) or remove (rm) files from it. You also need write permission to create new files (using touch or a file-redirect operator) or copy (cp) files into the directory.
This permission is very different on directories compared to files. Essentially, you can think of it as providing access to the directory. Having execute permission on a directory authorizes you to look at extended information on files in the directory (using ls -l, for instance) but also allows you to change your working directory (using cd) or pass through this directory on your way to a subdirectory underneath.
Lacking execute permission on a directory can limit the other permissions in interesting ways. For example, how can you add a new file to a directory (by leveraging the write permission) if you can't access the directory's metadata to store the information for a new, additional file? You cannot. It is for this reason that directory-type files generally offer execute permission to one or more of the user owner, group owner, or others.
[ Want to test your sysadmin skills? Take a skills assessment today. ]
You can modify file and directory permissions with the chmod command, which stands for "change mode." To change file permissions in numeric mode, you enter chmod and the octal value you desire, such as 744, alongside the file name. To change file permissions in symbolic mode, you enter a user class and the permissions you want to grant them next to the file name. For example:
This grants read, write, and execute for the user and group, and only read for others. In symbolic mode, chmod u represents permissions for the user owner, chmod g represents other users in the file's group, chmod o represents other users not in the file's group. For all users, use chmod a.
Maybe you want to change the user owner itself. You can do that with the chown command. Similarly, the chgrp command can be used to change the group ownership of a file.
Special permissions are available for files and directories and provide additional privileges over the standard permission sets that have been covered.
The "sticky bit" is a directory-level special permission that restricts file deletion, meaning only the file owner can remove a file within the directory.
Want to take a deeper dive into special permissions? Read Linux permissions: SUID, SGID, and sticky bit.
Understanding Linux file permissions (how to find them, read them, and change them) is an important part of maintaining and securing your systems. You can learn more about file permissions for Red Hat Enterprise Linux by checking out the documentation or by practicing with a self-paced lab on using file permissions.
[ Cheat sheet: Get a list of Linux utilities and commands for managing servers and networks. ]
The latest on IT automation for tech, teams, and environments
Updates on the platforms that free customers to run AI workloads anywhere
Explore how we build a more flexible future with hybrid cloud
The latest on how we reduce risks across environments and technologies
Updates on the platforms that simplify operations at the edge
The latest on the world’s leading enterprise Linux platform
Inside our solutions to the toughest application challenges
The future of enterprise virtualization for your workloads on-premise or across clouds

    Red Hat is an open hybrid cloud technology leader, delivering a consistent, comprehensive foundation for transformative IT and artificial intelligence (AI) applications in the enterprise. As a trusted adviser to the Fortune 500, Red Hat offers cloud, developer, Linux, automation, and application platform technologies, as well as award-winning services.

